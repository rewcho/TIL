# 5강. 반복문

## while 문

- 조건이 참인 동안 명령 블럭을 실행하는 반복문이다.
``` student = 1
while student <= 5:
      print(student, "번 학생의 성적을 처리합니다.")
      student += 1

1번 학생의 성적을 처리합니다.
2번 학생의 성적을 처리합니다.
3번 학생의 성적을 처리합니다.
4번 학생의 성적을 처리합니다.
5번 학생의 성적을 처리합니다.
```
- while 문은 무한루프를 걸 수 있는 반복문이며, 이걸을 해제하기 위해서는 break 명령문을 넣거나, Ctrl + C를 통해 명령문을 정지시켜야 한다.
- while 조건이 항상 True이면 무한루프에 오게 된다.
```
print("3+4=?")
while True:
    a = int(input('정답을 입력하세요: '))
    if a == 7 : break
print('참 잘했어요')

3+4=?
정답을 입력하세요: 6
정답을 입력하세요: 12
정답을 입력하세요: 7
참 잘했어요
```

## for 문
- 컬렉션의 요소를 하나씩 꺼내 명령 블럭을 실행하는 명령문.
- 컬렉션의 모든 요소를 다 사용하면 반복을 끝낸다.
- 반복문을 벗어나게 하려면 while문과 같이 break를 사용하면 되며, 잘못된 조건을 제외하면서 다음반복을 시작하기 위해서는 continue 명령어를 사용하면 된다.
```
score = [92, 86, 68, -1, 56]
for s in score:
    if s == -1:
      continue
    print(s)
print('성적 처리 끝')

92
86
68
56
성적 처리 끝
```
- 파이썬은 다른 언어와 다르게 리스트에선 값의 갯수로 판단한다. 다른 언어는 길이로 판단한다.
- 들여쓰기를 교정하기 위해서 오른쪽으로는 tap키, 왼쪽으로는 shift+tab키로 교정한다.
- 루프 안에 루프를 실행하는 것을 **이중 루프**라고 한다.
- 데이터를 읽을 때는 열보다 행으로 읽을 때 더 효율적이기 때문에, for문을 작성할 때는 행에 해당하는 x를 하위 들여쓰기로 하고 열에 해당하는 y를 상위 들여쓰기로 해야 한다.
- 이중루프를 사용할 때는 각 행의 길이는 종속되지 않기 때문에 고정되지 않고 변할 수 있다.



# 6강. 함수
- 코드를 짜다보면 반복되는 코드가 생성되는데, 이 반복을 최소화하기 위해 함수를 정의하여 해결한다.
- 되도록 코드중복을 피하는 것이 좋은데, 왜냐하면 사람이 하는 일이기에 반복된 일을 계속하기 힘드며 실수도 많이 할 수 있기 때문이다. 따라서 이를 피하기 위해 사용하는 것이 함수이다.
```
def calcsum(n):
    total = 0
    for num in range(n+1):
      total += num
    
    return total

print(" ~ 4 =", calcsum(4))
print(" ~ 10 =", calcsum(10))

~ 4 = 10
~ 10 = 55
```

- 함수로 값을 전달했을 때 이를 저장하는 변수를 **인수**라고 한다.
- 함수의 실행결과를 호출한 곳으로 넘기는 값을 **리턴값**이라고 한다.
- 인수 목록을 argument라고 부른다.
- 인수는 변수선언만 하면 되며, 따로 초기화할 필요는 없다.
- 인수를 초기화하려면 호출문 등 출력할 때 인수로 입력하면 된다.
- 인수가 알고리즘 시작이고, 코드가 함수, return이 결과값으로 이해하면 된다.
- 출력 인수로 호출문이 보이면 호출문 자체를 보이는 것이 아니라 결과를 출력한다는 뜻이다.
- 여러 개의 인수를 사용할 때는 () 안에서 ,를 사용한다.
- return을 만나면 함수의 실행을 종료하고 함수 호출했던 곳으로 돌아간다.
- 인수를 여러개 사용할 때 순서를 기준으로 mapping이 되기 때문에 순서를 잘 지켜야 한다.
- 만약 함수를 돌리는데 오류가 뜨면 return을 초기화하면 된다.
- 매개변수, srp(함수는 한가지 일만 해야 한다.)를 검색
- None은 어떠한 산술연산을 할 수가 없고, 오로지 진위여부만을 판단가능하다.

- 아무것도 안하고 넘어갈 때가 있는데, 이 때 쓰이는 명령어가 `pass`이다. 이 때 함수는 반드시 코드 블럭이 있어야 하며, 실제 구현을 나중으로 미루고자 할 때 pass를 지정한다.
```
def calctotal():
    # 나중에 완성할 것
    pass

if score >= 90:
  pass

else:
  pass
```


- 아직 정해지지 않은 함수를 signature라고 부른다.

- 고정되지 않은 인수를 **가변 인수**라고 하며, 호출 시 원하는 만큼 인수를 지정할 수 있다.
- 함수에서는 가변인수를 튜플 변수로 받는다.
- 인수명 앞에 "*"를 붙이면 가변인수라는 뜻이다. 위치만 맵핑이 된다.
- a(*ints)로 a(1,2,3)은 int(1,2,3)과 뜻이 같다.
- 가변인수는 가장 마지막에 위치하여야 하고, 가변인수가 아닌 것은 앞에다 위치시켜야 한다.
- 범위가 정해진 인수의 경우 컬렉션에 해당하므로, 개별적으로 펼쳐서 특정을 하기 위해서도 *를 사용하여야 한다. 이 기능은 현재 파이썬에만 존재한다.
- 가변인수를 정할 때, default 값은 항상 뒤에서 배정해야 하며, 앞으로 배정하면 인식하지 못한다.
- 가변 인수는 하나만 사용 가능하다.
```
def intsum(*ints):
    total = 0
    for num in ints:
        total += num

    return total

print(intsum(1,2,3))
print(intsum(5,7,9,11,13))
print(intsum(8,9,6,2,9,7,5,8))

6
45
54
```

- 함수 호출 시 인수가 지정되지 않았을 때 사용할 값을 **인수의 기본값**이라고 하며, 함수 정의 시 인수에 값을 대입한다.
- 인수 목록의 마지막 부분에 배정하며, 중간에 배정 시 구분이 불가하다는 것을 유념해야 한다.

```
def calcstep(begin, end, step):
    total = 0
    for num in range(begin, end+1, step):
        total += num

    return total

  print("1 ~ 10 =", calcstep(1, 10, 2))
  print("2 ~ 10 =", calcstep(2. 10. 2))

  1 ~ 10 = 25
  2 ~ 10 = 30
```

- 일반적으로 함수 호출 시 인수의 배치 순서대로 매칭이 되지만, 따로 명명하면 순서가 달라도 원하는 방식으로 매칭을 할 수가 있다. 이러한 명칭 인수를 **키워드 인수**라고 한다.
```
def calcstep(begin, end, step):
    total = 0
    for num in range(begin, end +1, step):
        total += num

    return total
print("3 ~ 5 =", calcstep(3, 5, 1))
print("3 ~ 5 =", calcstep(step=1, end=5, begin=3))
print("3 ~ 5 =", calcstep(3, step=1, end=5))

  3 ~ 5 = 12
  3 ~ 5 = 12
  3 ~ 5 = 12
```


- 키워드 가변 인수를 가변 개수로 전달할 때 ** 기호로 지정하며, 이 때 타입은 **사전(dictionary)**가 된다. 다른 언어에서는 map이란 용어를 사용한다.



## 변수의 범위(scope)

함수의 범위 내에서 사용된 변수로 지역변수가 있으며, 함수의 범위 밖에서 사용된 변수로 전역변수가 있다.



### 지역 변수

- 함수 내에서 사용된 변수
- 함수 내에서만 사용가능
  - 함수 밖에서 사용 불가
- LIFO(last in first out) 속성을 가지고 있는 것을 **stack**이라고 부르며, 지역변수와 매우 밀접한 관계에 있다.
- 매개변수도 지역 변수이다.
- 지역 변수는 stack의 함수 frame에 생긴다.
- 호출이 되면 지역변수가 생기고 return이 되어 함수가 끝나면 memory에서 사라진다. 이것을 변수의 life-cycle이라고 부른다.
- 변수의 접근범위(access scope)는 자신의 지역 변수나 전역 변수만 해당이 되지만 다른 함수가 진행이 된다고 해서 life-cycle이 끝난 것은 아니다.



## 전역 변수
- 어디서든 접근 가능한 변수이며, 탑 레벨에서 사용되는 변수이다.
```
salerate = 0.9

def kin():
    print("오늘의 할인율:", salerate)

def lee():
    price = 1000
    print("가격 :", price * salerate)

kin()
salerate = 1.1
lee()

오늘의 할인율 : 0.9
가격 : 1100.0
```

- 지역 변수를 새로 =를 쓰면 write 한  것이 되기 때문에 스택이 달라서 다른 변수로 인식이 된다. 따라서 전역 변수를 불러오는 것이 아니기 때문에 read할 때 주의해야 한다.
```
price = 1000

def sale():
    price = 500
  
sale()
print(price)

1000
```
- 따라서 블록 안에 전역 변수를 사용하고 싶으면 global 이란 수식어를 붙여서 전역변수를 특정하는 것임을 나타내야 한다.
```
price = 1000

def sale():
    global price
    price = 500
  
sale()
print(price)

500
```

- 매개변수 위에서 바뀌는 함수 값은 영향을 안 받는다. 이 현상을 call by value라고 하는데, 이는 지역변수로 사본이 만들어져 함수에서는 이 사본을 조작하는 것이지만, 출력은 원본을 하는 것이라 원본에는 아무런 조작이 가해지지 않기 때문이다.



# 7강. 문자열 관리

순서(index)가 정해진 서열을 sequence라고 부르는데, 문자열도 일종의 sequence이자 컬렉션에 해당한다.

- 문자열을 앞에서 셀 때는 0부터 인덱싱이 일어나며, 뒤에서부터 셀 -1부터 인덱싱된다.
```
s = "python"
print(s[2]) 
print(s[-2])

t
o
```

- 문자열을 크기는 `len(변수)`로 표현하며, 해당 길이만큼 인덱싱을 한다.


## 슬라이싱(중요)

- 문자열[bigin : end : step]
  - step : 음수이면 뒤에서부터 진행
- 슬라이싱할 때 썼던 것이 문자열이라면 결과값도 문자열 타입에 해당한다. 숫자로 써져있더라도 수치가 아닌 문자이다.
```
s = "0123456789"

print(s[2:5])
print(s[3:])
print(s[:4])

234
3456789
0123
```

```
dates = "월화수목금토일"
print(dates[::2])
print(dates[::-1])
월수금일
일토금목수화월
```
- 문자열은 다양한 메서드가 있으며, 해당 역할에 대해 다음과 같은 메서드가 있다.
  1. 검색
  
    | 종류        | 기능                                                        |
    | ----------- | ----------------------------------------------------------- |
    | .find(str)  | str 문자열을 찾아 인덱스 변환, 없으면 -1 반환               |
    | .rfind(str) | 뒤에서 str 문자열을 찾아 인덱스 반환, 없으면 -1 반환        |
  | .index(str) | find()와 거의 동일하나, 없으면 반환이 안 되고 예외가 발생함 |
    | .count(str) | str 문자열이 몇 번 등장하는지 리턴                          |
  
    
  
  2. 조사
  
    | 종류               | 기능                                      |
    | ------------------ | ----------------------------------------- |
    | 단어 in 문자열     | 해당 단어가 들어가 있는지 진위판정.       |
    | 단어 not in 문자열 | 해당 단어가 없는지 진위판정.              |
    | .startswith(str)   | 앞에서부터 시작하여 존재하는지 판정.      |
    | .endswith(str)     | 뒤에서부터 시작하여 존재하는지 판정. bool |
  - is가 들어간 매서드는 모두 부울린 타입이다.
  3. 변경
  
    | 종류          | 기능                                                     |
    | ------------- | -------------------------------------------------------- |
    | .lower()      | 모든 문자를 소문자로 변경                                |
    | .upper()      | 모든 문자를 대문자로 변경                                |
    | .swapcase()   | 대문자는 소문자로, 소문자는 대문자로 변환                |
    | .capitalize() | 첫 글자는 대문자, 나머지는 모두 소문자로 변환            |
    | .title()      | 모든 단어의 첫글자를 대문자, 나머지는 모두 소문자로 변환 |
    | .strip()      | 좌우에 있는 공백을 제거                                  |
    | .lstrip()     | 왼쪽에 있는 공백을 제거                                  |
    | .rtrip()      | 오른쪽에 있는 공백을 제거                                |
  
    
  
  4. 분할
  
    | 종류                    | 기능                                                         |
    | ----------------------- | ------------------------------------------------------------ |
    | .slpit(구분자)          | 구분자를 기준으로 단어를 분리하여 리스트로 리턴, 디폴트는 공백 |
    | .splitlines()           | 개행 문자를 기준으로 분리. 개행문자만 존재할 시 비어있는 문자열로 처리 |
    | 결합문자열.join(문자열) | 글자들을 결합문자열로 연결하여 하나의 문자열로 리턴          |
  
    
```
  s = "짜장 짬뽕 탕수육"
print(s.split())
s2 = "서울->대전->대구->부산"
cities = s2.split("->")
print(cities)

for city in cities:
    print(city)


['짜장', '짬뽕', '탕수육']
['서울', '대전', '대구', '부산']
서울
대전
대구
부산
```
  5. 대체
    
  | 종류                             | 기능                                               |
  | -------------------------------- | -------------------------------------------------- |
  | .replace(기존문자열, 대체문자열) | 기존 문자열을 대체 문자열로 대체                   |
  | .center(폭숫자)                  | 좌우에 공백을 채워 폭숫자만큼 문자열 길이를 맞춤   |
  | .ljust(폭숫자)                   | 왼쪽에 공백을 채워 폭숫자만큼 문자열 길이를 맞춤   |
  | .rjust(폭숫자)                   | 오른쪽에 공백을 채워 폭숫자만큼 문자열 길이를 맞춤 |
  
  
  ```s = "독도는 일본땅. 대마도도 일본땅"
print(s)
print(s.replace("일본", "한국"))

독도는 일본땅. 대마도도 일본땅
독도는 한국땅. 대마도도 한국땅
  ```

- 문자열은 **불변객체**이다. 한번 초기화되면 해당 값을 변경할 수 없다. 변경하기 위해서는 새로운 연산자로 해야 한다.
- split는 사용빈도가 높은 매서드 중 하나이다.
- 대체 매서드로 replace를 많이 이용한다.

## 포맷팅
다양한 변수를 만들다보면 가독성이 떨어져서 해당 변수에 어떤 값을 넣는지 확인하기 어려울 때가 있다. 이 때 포맷팅을 이용하여 해당 자리에 원하는 변수를 집어넣어 보기 쉽게 정리하는 것을 **포맷팅**이라고 한다.

포맷팅은 버젼별로 방식의 차이가 있다.
1. 2.0 ver
- `%d` : 정수
- `%f` : 실수
- `%s` : 문자열
- `%c` : 문자 하나
- `%h` : 16진수
- `%o` : 8진수
- `%%` : % 문자
- `%[-]` : 폭, 폭에는 소수점에 포함
- `%[.유효자리수]` : 반올림 발생

2. 3.0 ver 선형 포맷팅
- "{[:포맷문자열]} ".format(값...)
- "{인뎃스[:포맷문자열]} ".format(값...)
- "{변수명[:포맷문자열]} ".format(값...)
```
name = "한결"
age = 16
height = 162.5
print("이름:{0}, 나이: {1}, 키: {2}".format(name, age, height))
print("이름:{2}, 나이: {1}, 키: {0}".format(height, age, name))
print("이름:{name}, 나이: {age}, 키: {height}".format(
age=20, height=160.9, name="길동"))

이름:한결, 나이: 16, 키: 162.5
이름:한결, 나이: 16, 키: 162.5
이름:길동, 나이: 20, 키: 160.9
```

3. 3.7 ver 선형 포맷팅
```
socialnum = '001212-3451231'
age = 16

# '생년-월-일'로 포맷팅 해서 출력
# 출신 지역 코드 출력
year = socialnum[:2]
month = socialnum[2:4]
date = socialnum[4:6]
region = socialnum[8:10]
gender = socialnum[7]
if gender == '1' or gender == '2':
    year = '19' + year
else :
    year = '20' + year

print(f"생일:{year}-{month}-{date}, age: {age}")
print(f"지역코드: {region}")

생일:2000-12-12, age: 16
지역코드: 45
```
