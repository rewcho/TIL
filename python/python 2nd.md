# 5강. 반복문

## while 문

- 조건이 참인 동안 명령 블럭을 실행하는 반복문이다.
``` student = 1
while student <= 5:
      print(student, "번 학생의 성적을 처리합니다.")
      student += 1

1번 학생의 성적을 처리합니다.
2번 학생의 성적을 처리합니다.
3번 학생의 성적을 처리합니다.
4번 학생의 성적을 처리합니다.
5번 학생의 성적을 처리합니다.
```
- while 문은 무한루프를 걸 수 있는 반복문이며, 이걸을 해제하기 위해서는 break 명령문을 넣거나, Ctrl + C를 통해 명령문을 정지시켜야 한다.
- while 조건이 항상 True이면 무한루프에 오게 된다.
```
print("3+4=?")
while True:
    a = int(input('정답을 입력하세요: '))
    if a == 7 : break
print('참 잘했어요')

3+4=?
정답을 입력하세요: 6
정답을 입력하세요: 12
정답을 입력하세요: 7
참 잘했어요
```

## for 문
- 컬렉션의 요소를 하나씩 꺼내 명령 블럭을 실행하는 명령문.
- 컬렉션의 모든 요소를 다 사용하면 반복을 끝낸다.
- 반복문을 벗어나게 하려면 while문과 같이 break를 사용하면 되며, 잘못된 조건을 제외하면서 다음반복을 시작하기 위해서는 continue 명령어를 사용하면 된다.
```
score = [92, 86, 68, -1, 56]
for s in score:
    if s == -1:
      continue
    print(s)
print('성적 처리 끝')

92
86
68
56
성적 처리 끝
```
- 파이썬은 다른 언어와 다르게 리스트에선 값의 갯수로 판단한다. 다른 언어는 길이로 판단한다.
- 들여쓰기를 교정하기 위해서 오른쪽으로는 tap키, 왼쪽으로는 shift+tab키로 교정한다.
- 루프 안에 루프를 실행하는 것을 **이중 루프**라고 한다.
- 데이터를 읽을 때는 열보다 행으로 읽을 때 더 효율적이기 때문에, for문을 작성할 때는 행에 해당하는 x를 하위 들여쓰기로 하고 열에 해당하는 y를 상위 들여쓰기로 해야 한다.
- 이중루프를 사용할 때는 각 행의 길이는 종속되지 않기 때문에 고정되지 않고 변할 수 있다.



# 6강. 함수
- 코드를 짜다보면 반복되는 코드가 생성되는데, 이 반복을 최소화하기 위해 함수를 정의하여 해결한다.
- 되도록 코드중복을 피하는 것이 좋은데, 왜냐하면 사람이 하는 일이기에 반복된 일을 계속하기 힘드며 실수도 많이 할 수 있기 때문이다. 따라서 이를 피하기 위해 사용하는 것이 함수이다.
```
def calcsum(n):
    total = 0
    for num in range(n+1):
      total += num
    
    return total

print(" ~ 4 =", calcsum(4))
print(" ~ 10 =", calcsum(10))

~ 4 = 10
~ 10 = 55
```

- 함수로 값을 전달했을 때 이를 저장하는 변수를 **인수**라고 한다.
- 함수의 실행결과를 호출한 곳으로 넘기는 값을 **리턴값**이라고 한다.
- 인수 목록을 argument라고 부른다.
- 인수는 변수선언만 하면 되며, 따로 초기화할 필요는 없다.
- 인수를 초기화하려면 호출문 등 출력할 때 인수로 입력하면 된다.
- 인수가 알고리즘 시작이고, 코드가 함수, return이 결과값으로 이해하면 된다.
- 출력 인수로 호출문이 보이면 호출문 자체를 보이는 것이 아니라 결과를 출력한다는 뜻이다.
- 여러 개의 인수를 사용할 때는 () 안에서 ,를 사용한다.
- return을 만나면 함수의 실행을 종료하고 함수 호출했던 곳으로 돌아간다.
- 인수를 여러개 사용할 때 순서를 기준으로 mapping이 되기 때문에 순서를 잘 지켜야 한다.
- 만약 함수를 돌리는데 오류가 뜨면 return을 초기화하면 된다.
- 매개변수, srp(함수는 한가지 일만 해야 한다.)를 검색
- None은 어떠한 산술연산을 할 수가 없고, 오로지 진위여부만을 판단가능하다.

- 아무것도 안하고 넘어갈 때가 있는데, 이 때 쓰이는 명령어가 `pass`이다. 이 때 함수는 반드시 코드 블럭이 있어야 하며, 실제 구현을 나중으로 미루고자 할 때 pass를 지정한다.
```
def calctotal():
    # 나중에 완성할 것
    pass

if score >= 90:
  pass

else:
  pass
  ```


- 아직 정해지지 않은 함수를 signature라고 부른다.

- 고정되지 않은 인수를 **가변 인수**라고 하며, 호출 시 원하는 만큼 인수를 지정할 수 있다.
- 함수에서는 가변인수를 튜플 변수로 받는다.
- 인수명 앞에 "*"를 붙이면 가변인수라는 뜻이다. 위치만 맵핑이 된다.
- a(*ints)로 a(1,2,3)은 int(1,2,3)과 뜻이 같다.
- 가변인수는 가장 마지막에 위치하여야 하고, 가변인수가 아닌 것은 앞에다 위치시켜야 한다.
- 범위가 정해진 인수의 경우 컬렉션에 해당하므로, 개별적으로 펼쳐서 특정을 하기 위해서도 *를 사용하여야 한다. 이 기능은 현재 파이썬에만 존재한다.
- 가변인수를 정할 때, default 값은 항상 뒤에서 배정해야 하며, 앞으로 배정하면 인식하지 못한다.
- 가변 인수는 하나만 사용 가능하다.
```
def intsum(*ints):
    total = 0
    for num in ints:
        total += num

    return total

print(intsum(1,2,3))
print(intsum(5,7,9,11,13))
print(intsum(8,9,6,2,9,7,5,8))

6
45
54
```

- 함수 호출 시 인수가 지정되지 않았을 때 사용할 값을 **인수의 기본값**이라고 하며, 함수 정의 시 인수에 값을 대입한다.
- 인수 목록의 마지막 부분에 배정하며, 중간에 배정 시 구분이 불가하다는 것을 유념해야 한다.

```
def calcstep(begin, end, step):
    total = 0
    for num in range(begin, end+1, step):
        total += num

    return total

  print("1 ~ 10 =", calcstep(1, 10, 2))
  print("2 ~ 10 =", calcstep(2. 10. 2))

  1 ~ 10 = 25
  2 ~ 10 = 30
  ```

- 일반적으로 함수 호출 시 인수의 배치 순서대로 매칭이 되지만, 따로 명명하면 순서가 달라도 원하는 방식으로 매칭을 할 수가 있다. 이러한 명칭 인수를 **키워드 인수**라고 한다.
```
def calcstep(begin, end, step):
    total = 0
    for num in range(begin, end +1, step):
        total += num

    return total
print("3 ~ 5 =", calcstep(3, 5, 1))
print("3 ~ 5 =", calcstep(step=1, end=5, begin=3))
print("3 ~ 5 =", calcstep(3, step=1, end=5))

  3 ~ 5 = 12
  3 ~ 5 = 12
  3 ~ 5 = 12
  ```


- 키워드 가변 인수를 가변 개수로 전달할 때 ** 기호로 지정하며, 이 때 타입은 **사전(dictionary)**가 된다. 다른 언어에서는 map이란 용어를 사용한다.



## 변수의 범위(scope)

함수의 범위 내에서 사용된 변수로 지역변수가 있으며, 함수의 범위 밖에서 사용된 변수로 전역변수가 있다.



### 지역 변수

- 함수 내에서 사용된 변수
- 함수 내에서만 사용가능
  - 함수 밖에서 사용 불가
- LIFO(last in first out) 속성을 가지고 있는 것을 **stack**이라고 부르며, 지역변수와 매우 밀접한 관계에 있다.
- 매개변수도 지역 변수이다.
- 지역 변수는 stack의 함수 frame에 생긴다.
- 호출이 되면 지역변수가 생기고 return이 되어 함수가 끝나면 memory에서 사라진다. 이것을 변수의 life-cycle이라고 부른다.
- 변수의 접근범위(access scope)는 자신의 지역 변수나 전역 변수만 해당이 되지만 다른 함수가 진행이 된다고 해서 life-cycle이 끝난 것은 아니다.



## 전역 변수
- 어디서든 접근 가능한 변수이며, 탑 레벨에서 사용되는 변수이다.
```
salerate = 0.9

def kin():
    print("오늘의 할인율:", salerate)

def lee():
    price = 1000
    print("가격 :", price * salerate)

kin()
salerate = 1.1
lee()

오늘의 할인율 : 0.9
가격 : 1100.0
```

- 지역 변수를 새로 =를 쓰면 write 한  것이 되기 때문에 스택이 달라서 다른 변수로 인식이 된다. 따라서 전역 변수를 불러오는 것이 아니기 때문에 read할 때 주의해야 한다.
```
price = 1000

def sale():
    price = 500
  
sale()
print(price)

1000
```
- 따라서 블록 안에 전역 변수를 사용하고 싶으면 global 이란 수식어를 붙여서 전역변수를 특정하는 것임을 나타내야 한다.
```
price = 1000

def sale():
    global price
    price = 500
  
sale()
print(price)

500
```

- 매개변수 위에서 바뀌는 함수 값은 영향을 안 받는다. 이 현상을 call by value라고 하는데, 이는 지역변수로 사본이 만들어져 함수에서는 이 사본을 조작하는 것이지만, 출력은 원본을 하는 것이라 원본에는 아무런 조작이 가해지지 않기 때문이다.



# 7강. 문자열 관리

순서(index)가 정해진 서열을 sequence라고 부르는데, 문자열도 일종의 sequence이자 컬렉션에 해당한다.



## 슬라이싱(중요)

- 문자열[bigin : end : step]
  - step : 음수이ㅏ면 뒤에서부터 진행
- 슬라이싱할 때 썼던 것이 문자열이라면 결과값도 문자열 타입에 해당한다. 숫자로 써져있더라도 수치가 아닌 문자이다.
- is가 들어간 매서드는 모두 부울린 타입이다.
- 문자열은 **불변객체**이다. 한번 초기화되면 해당 값을 변경할 수 없다. 변경하기 위해서는 새로운 연산자로 해야 한다.
- split는 사용빈도가 높은 매서드 중 하나이다.
- 대체 매서드로 replace를 많이 이용한다.