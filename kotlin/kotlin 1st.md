- 글자의 첫글자가 대문자인 것은 클래스로 정의되어있는 객체이다.
- 문장과 표현식 중에 문장이 더 넓은 범위이며, 둘을 구별하는 방법은 0가지가 있다.
- 첫째는 대입문과 사용여부이다. 대입문을 같이 사용하면 조건식(즉 값이 결정), 그렇지가 않으면 조건문이다.


$ 변수명
$ {표현식}      $ {}    와 같이 표현된다.

함수에 리턴값은 생략가능하며, 생략하면 unit으로 된다.(c++의 void 타입에 해당)

alt + Enter 를 치면 취할 수 있는 조치사항을 자동으로 검색해서 띄어준다.

한줄짜리 함수의 경우 단일 표현식 함수라고 부르며, 한줄짜리 함수는 단순히 줄 하나로 표시하는 것이 아닌 한 개의 리턴값과 같은 것을 표현할 때도 한 줄로 본다.

## 익명 함수와 함수 타입 ##
{ 매개변수 ->
    함수 본체
    }

여기에서 ->가 람다 함수 표시를 의미한다. 파이썬과 달리 람다 함수의 라인 수에는 제한이 없다. 마지막 라인이 표현식인 경우 리턴값을 표시 안해도 된다.

{} 안은 람다 함수 정의, ()는 해당 함수를 호출하겠다는 뜻.

매개변수가 1개인 경우 따로 선언문이 없이 it 키워드로 사용가능하다.

초기 값을 통해서 :(string int) ->string생략


?.xxxxx 로 구성하면 null이 아니면 . 이후 실행
null이면 실행하지 않고 null 리턴

이러한 ?연산자를 엘비스 연산자

파이썬처럼 코틀린도 string은 불변객체이다.

apply와 let은 사용 빈도 높음

c++에서 this는 파이썬의 self와 유사(자신을 가리키는 포인터)이지만, 코틀린에서는 자신을 가리키는 참조에 해당한다.

수신객체가 this가 되고 리턴은 this가 가리키는 수신객체가 된다.

run은 this를 리턴하지 않고 let처럼 마지막 표현식이 리턴값을 갖는다.

run은 apply처럼 사용하되 리턴값을 다른 것으로 지정하고 싶을 때 사용한다.

with도 run처럼 this가 바뀌어서 운영하고, 마지막 값이 리턴된다. 수신객체를 매개변수로 지정하는 방식으로 호출된다. 수신객체와 함수를 모두 리턴하므로 매개변수가 2개이다.

참고로 파이썬에서는 with 블럭 내의 함수를 close할 떄 with를 사용한다.

인덱스 할때 예외가 발생하면 유효범위에 대한 이해가 부족해서 생긴 것이다(?).

코틀린의 경우 같은 프로젝트에서 같은 디렉토리에 다른 파일에 사용하는 함수들은 서로 영향을 받기 때문에 같은 이름을 쓰는 함수가 있으면 에러가 난다. 이를 해결하기 위해서는 패키지를 만들어 관리해야 한다. 